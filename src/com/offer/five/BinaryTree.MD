# 二叉树(Binary Tree)

> 每个节点最多有两个子树的树结构.通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。
> 一棵深度为k，且有2^k-1个结点的二叉树，称为满二叉树。这种树的特点是每一层上的结点数都是最大结点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且或者最后一层是满的，或者是在右边缺少连续若干结点，则此二叉树为完全二叉树。具有n个结点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2k-1个叶子结点，至多有2k-1个结点。

## 定义
2^k - 1 二叉树是一个连通的无环图,并且每一个节点的度不大于3.有根二叉树还要满足根节点的度不大于2.有了根节点之后,每个顶点定义了唯一的父节点和最多的2个子节点.然后,没有足够的信息来区分左节点和右节点.如果不考虑连通性,允许图中有多个连通分量,这样的结构叫做森林.
## 基本概念
二叉树是递归定义的，其结点有左右子树之分，逻辑上二叉树有五种基本形态：

1. 空二叉树——如图(a)；
2. 只有一个根结点的二叉树——如图(b)；
3. 只有左子树——如图(c)
4. 只有右子树——如图(d)
5. 完全二叉树——如图(e)

![二叉树](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D250/sign=d3868698e71190ef05fb95dafe1a9df7/314e251f95cad1c8f135aa527f3e6709c93d513c.jpg)

### 类型
1. 完全二叉树——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。
2. 满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。
3. 平衡二叉树——平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

## 相关术语

* 树的结点（node）：包含一个数据元素及若干指向子树的分支；
* 孩子结点（child node）：结点的子树的根称为该结点的孩子；
* 双亲结点：B 结点是A 结点的孩子，则A结点是B 结点的双亲；
* 兄弟结点：同一双亲的孩子结点； 堂兄结点：同一层上结点；
* 祖先结点: 从根到该结点的所经分支上的所有结点
* 子孙结点：以某结点为根的子树中任一结点都称为该结点的子孙
* 结点层：根结点的层定义为1；根的孩子为第二层结点，依此类推；
* 树的深度：树中最大的结点层
* 结点的度：结点子树的个数
* 树的度： 树中最大的结点度。
* 叶子结点：也叫终端结点，是度为 0 的结点；
* 分枝结点：度不为0的结点；
* 有序树：子树有序的树，如：家族树；
* 无序树：不考虑子树的顺序；

## 二叉树性质
1. 在非空二叉树中，第i层的结点总数不超过
, i>=1；
2. 深度为h的二叉树最多有
个结点(h>=1)，最少有h个结点；
3. 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1；
4. 具有n个结点的完全二叉树的深度为
（注：[ ]表示向下取整）
5. 有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：
若I为结点编号则 如果I>1，则其父结点的编号为I/2；
如果2*I<=N，则其左孩子（即左子树的根结点）的编号为2*I；若2*I>N，则无左孩子；
如果2*I+1<=N，则其右孩子的结点编号为2*I+1；若2*I+1>N，则无右孩子。
6. 给定N个结点，能构成h(N)种不同的二叉树。
h(N)为卡特兰数的第N项。h(n)=C(2*n，n)/(n+1)。
7. 设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i [2]  

## 存储结构

### 顺序存储方式
```C++
typenode=record
data:datatype
l,r:integer;
end;
vartr:array[1..n]ofnode;
```

### 链表存储方式
```C++
typebtree=^node；
node=record
data:datatye;
lchild,rchild:btree;
end;
```

## 二叉树遍历
遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。
设L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先根次序遍历），LDR（称为中根次序遍历），LRD （称为后根次序遍历）。

* 先序遍历
首先访问根，再先序遍历左（右）子树，最后先序遍历右（左）子树，C语言代码如下：
```C++
void XXBL(tree *root){
    //DoSomethingwithroot
    if(root->lchild!=NULL)
        XXBL(root->lchild);
    if(root->rchild!=NULL)
        XXBL(root->rchild);
}
```

* 中序遍历
首先中序遍历左（右）子树，再访问根，最后中序遍历右（左）子树，C语言代码如下
```C++
void ZXBL(tree *root)
{
    if(root->lchild!=NULL)
        ZXBL(root->lchild);
        //Do something with root
    if(root->rchild!=NULL)
        ZXBL(root->rchild);
}
```

* 后序遍历
首先后序遍历左（右）子树，再后序遍历右（左）子树，最后访问根，C语言代码如下
```C++
void HXBL(tree *root){
    if(root->lchild!=NULL)
        HXBL(root->lchild);
    if(root->rchild!=NULL)
        HXBL(root->rchild);
        //Do something with root
}
```
* 层次遍历
即按照层次访问，通常用队列来做。访问根，访问子女，再访问子女的子女（越往后的层次越低）（两个子女的级别相同）

